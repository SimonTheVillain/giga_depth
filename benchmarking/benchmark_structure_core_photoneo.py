import os.path

import open3d as o3d
import numpy as np
import cv2

base_path = "/media/simon/ssd_datasets/datasets"


def prepare_gt():
    gt_path = f"{base_path}/structure_core_photoneo_test"
    eval_path = f"{base_path}/structure_core_photoneo_test_results/GigaDepth66LCN"
    output_path = f"{base_path}/structure_core_photoneo_test_results/Photoneo"
    focal = 1.1154399414062500e+03
    baseline = 0.0634
    cxy = (604, 457)

    for i in range(11):
        if not os.path.exists(f"{output_path}/{i:03}"):
            os.mkdir(f"{output_path}/{i:03}")
        for j in range(4):
            pth_src = f"{eval_path}/{i:03}/{j}.exr"
            pth_gt = f"{gt_path}/{i:03}/gt.ply"
            pth_out = f"{output_path}/{i:03}/{j}.exr"

            print(pth_src)
            disp = cv2.imread(pth_src, cv2.IMREAD_UNCHANGED)
            pcd = generate_pcl(disp)

            # TODO: RENAME TO PCD_REF
            print("Load groundtruth ply")
            print(pth_gt)
            pcd_ref = o3d.io.read_point_cloud(pth_gt)
            pcd_ref = pcd_ref.scale(1.0 / 1000.0, np.zeros((3, 1)))

            print("Apply point-to-point ICP")
            threshold = 0.2
            trans_init = np.identity(4)
            reg_p2p = o3d.pipelines.registration.registration_icp(
                pcd_ref, pcd, threshold, trans_init,
                o3d.pipelines.registration.TransformationEstimationPointToPoint())
            print(reg_p2p)
            print("Transformation is:")
            print(reg_p2p.transformation)
            pcd_ref.transform(reg_p2p.transformation)  # apply first transformation

            print("Apply FINE point-to-point ICP")
            threshold = 0.02
            trans_init = np.identity(4)
            reg_p2p = o3d.pipelines.registration.registration_icp(
                pcd_ref, pcd, threshold, trans_init,
                o3d.pipelines.registration.TransformationEstimationPointToPoint())
            print(reg_p2p)
            pcd_ref.transform(reg_p2p.transformation)  # apply second transformation

            print("Transformation is:")
            print(reg_p2p.transformation)

            print("Initial alignment")
            evaluation = o3d.pipelines.registration.evaluate_registration(
                pcd, pcd_ref, threshold, trans_init)
            print(evaluation)

            disp = generate_disp(pcd_ref)
            cv2.imwrite(pth_out, disp)




def generate_disp(pcd):
    focal = 1.1154399414062500e+03
    baseline = 0.0634
    cxy = (604, 457)
    depth = np.ones((896, 1216), dtype=np.float32) * 100.0
    for pt in pcd.points:
        d = pt[2]
        if d==0.0:
            continue
        xy = [pt[0] * focal / d + cxy[0], pt[1] * focal / d + cxy[1]]
        xy = [int(xy[0]), int(xy[1])]
        if xy[0] >=0 and xy[0] < depth.shape[1] and xy[1] >= 0 and xy[1] < depth.shape[0]:
            depth[xy[1], xy[0]] = min(d, depth[xy[1], xy[0]])

    depth[depth == 100.0] = 0


    disp = baseline * focal / depth
    disp[depth == 0] = 0
    cv2.imshow("depth", depth * 0.1)
    cv2.imshow("disp", disp * 0.01)
    cv2.waitKey(100)
    return disp
def generate_pcl(disp):
    focal = 1.1154399414062500e+03
    baseline = 0.0634
    cxy = (604, 457)
    pts = []
    for i in range(disp.shape[0]):
        for j in range(disp.shape[1]):
            d = disp[i, j]
            if d > 10 and d < 100:
                d = baseline * focal * 0.5 / d
                x = (j - cxy[0] * 0.5) * d / (focal * 0.5)
                y = (i - cxy[1] * 0.5) * d / (focal * 0.5)
                pts.append([x, y, d])

    pts = np.array(pts)
    # TODO: RENAME TO PCD
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(pts)
    return pcd
if False:#directly load the depth generated by the structure core
    depth = cv2.imread(gt_path + "/depth0.png", cv2.IMREAD_UNCHANGED)
    pts = []
    for i in range(depth.shape[0]):
        for j in range(depth.shape[1]):
            d = depth[i, j]
            d = d / 1000.0
            if d > 0.1 and d < 10:
                # assume the depth is in millimeters:
                x = (j - cxy[0]) * d / focal
                y = (i - cxy[1]) * d / focal
                pts.append([x, y, d])
    pts = np.array(pts)
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(pts)




if False:
    disp = cv2.imread(eval_path + "/0.exr", cv2.IMREAD_UNCHANGED)
    pts = []
    for i in range(disp.shape[0]):
        for j in range(disp.shape[1]):
            d = disp[i, j]
            if d > 10 and d < 100:
                d = baseline * focal * 0.5 / d
                x = (j - cxy[0] * 0.5) * d / (focal * 0.5)
                y = (i - cxy[1] * 0.5) * d / (focal * 0.5)
                pts.append([x, y, d])

    pts = np.array(pts)
    # TODO: RENAME TO PCD
    pcd = o3d.geometry.PointCloud()
    pcd.points = o3d.utility.Vector3dVector(pts)

    # TODO: RENAME TO PCD_REF
    print("Load groundtruth ply")
    pcd_ref = o3d.io.read_point_cloud(gt_path + "/gt.ply")
    pcd_ref = pcd_ref.scale(1.0 / 1000.0, np.zeros((3, 1)))
    print("Apply point-to-point ICP")
    threshold = 0.02
    threshold = 0.2
    trans_init = np.identity(4)
    reg_p2p = o3d.pipelines.registration.registration_icp(
        pcd_ref, pcd, threshold, trans_init,
        o3d.pipelines.registration.TransformationEstimationPointToPoint())
    print(reg_p2p)
    print("Transformation is:")
    print(reg_p2p.transformation)
    pcd_ref.transform(reg_p2p.transformation)# apply first transformation


    print("Apply FINE point-to-point ICP")
    threshold = 0.02
    trans_init = np.identity(4)
    reg_p2p = o3d.pipelines.registration.registration_icp(
        pcd_ref, pcd, threshold, trans_init,
        o3d.pipelines.registration.TransformationEstimationPointToPoint())
    print(reg_p2p)
    pcd_ref.transform(reg_p2p.transformation)# apply second transformation

    print("Transformation is:")
    print(reg_p2p.transformation)


    print("Initial alignment")
    evaluation = o3d.pipelines.registration.evaluate_registration(
        pcd, pcd_ref, threshold, trans_init)
    print(evaluation)

    #print(pcd)
    #print(np.asarray(pcd.points))
    o3d.visualization.draw_geometries([pcd_ref, pcd])
    generate_disp(pcd_ref)


prepare_gt()